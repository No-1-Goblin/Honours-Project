using System;
using System.Collections;
using System.Collections.Generic;
using TMPro;
using Unity.VisualScripting;
using UnityEditor;
using UnityEngine;

public class LevelGenerator : MonoBehaviour
{
    // Reference to the generator settings the generator will use
    [SerializeField] private GeneratorSettings settings;
    // Reference to the prefab for rooms that the generator will use
    [SerializeField] private WaveFunctionCollapse roomPrefab;
    // List of all objects generated by the generator. Used for cleanup when deleting/creating new level
    private List<GameObject> generatedObjects = new();
    // List of objects that need their connectors populated
    private List<SnappablePiece> populationQueue = new();
    // The current target position of the level generator
    private Vector3 targetPos = new(0, 0, 0);
    // List of all positions the generator will place a room
    private List<Vector3> roomPositions = new();

    /// <summary>
    /// Get the generator's settings
    /// </summary>
    /// <returns></returns>
    public GeneratorSettings getSettings()
    {
        return settings;
    }

    /// <summary>
    /// Set the settings for the generator
    /// </summary>
    /// <param name="newSettings"></param>
    public void setGeneratorSettings(GeneratorSettings newSettings)
    {
        settings = newSettings;
    }

    /// <summary>
    /// Generate the level
    /// </summary>
    public void generateLevel()
    {
        // Clean up old level first
        deleteLevel();
        // Check that the generator settings are valid
        if (!validateGeneratorSettings())
        {
            Debug.Log("Invalid Generator Settings");
            return;
        }
        // Generate the positions to place all the rooms
        generateRoomPositions();
        // Generate the start point of the level. This will have the player on it
        SnappablePiece startPiece = generateStartPoint();
        // Population queue will be where new pieces that need their connectors populated go
        populationQueue = new();
        populationQueue.Add(startPiece);
        // Keep track of distance to the next room position. This is used to determine when to place a room
        float distanceToRoom = calculateDistanceToNextRoom(0);
        // <= Because we generate one additional room position, which is where the end piece will go
        for (int i = 0; i <= settings.roomCount; i++)
        {
            // Set our target position to where we want to place a room
            targetPos = roomPositions[i];
            distanceToRoom = calculateDistanceToNextRoom(i);
            // Keep placing pieces until we get close enough to our target to place a room as defined in generator settings
            while (populationQueue.Count != 0 && distanceToRoom > settings.roomDistanceTolerance)
            {
                // Populate the connectors of the first piece in the queue
                // We're checking to make sure we're successful in placing a piece. We fail if none of the pieces can be placed without colliding with an existing piece
                if (!populateConnections(populationQueue[0], targetPos))
                {
                    // If we fail, try level generation again
                    generateLevel();
                    return;
                }
                // Now we have successfully populated the level piece, remove it from the queue
                populationQueue.RemoveAt(0);
                // Recalculate distance to the target position before the while loop does its check
                distanceToRoom = calculateDistanceToNextRoom(i);
            }
            // Once we have reached where we want to place a room

            // If i != room count then it's a normal room
            if (i != settings.roomCount)
            {
                // Check we're successful in placing a room. We fail if it can't be placed without colliding with existing pieces
                if (!generateRoom())
                {
                    // If we fail, try level generation again
                    generateLevel();
                    return;
                }
            }
            // If i == room count then it's the end piece of the level
            // Check we're successful in placing the end piece. We fail if it can't be placed without colliding with existing pieces
            else if (!generateEndPoint())
            {
                {
                    // If we fail, try level generation again
                    generateLevel();
                    return;
                }
            }
        }
    }

    /// <summary>
    /// Check that the provided generator settings are valid for generation
    /// </summary>
    /// <returns></returns>
    private bool validateGeneratorSettings()
    {
        // Check we have settings
        if (settings == null)
            return false;
        // Check the settings have a tileset
        if (settings.tileset == null)
            return false;
        // Check the tileset has at least one start piece
        if (settings.tileset.startPieces.Count < 1)
            return false;
        // Check the tileset has at least one end piece
        if (settings.tileset.endPieces.Count < 1)
            return false;
        // Check the tileset has at least one standard piece
        // Realistically you're gonna want more than 1, but technically you can generate with just 1 in theory
        if (settings.tileset.standardPieces.Count < 1)
            return false;
        return true;
    }

    /// <summary>
    /// Generate the level piece at the beginning of the level
    /// </summary>
    /// <returns></returns>
    private SnappablePiece generateStartPoint()
    {
        // We grab a random piece from the start piece list and instantiate it
        // We don't need to do any collision checking since it's the only piece in the level
        GameObject startPiece = Instantiate(getRandomPiece(settings.tileset.startPieces), transform).gameObject;
        // Rotate the level piece by a random cardinal direction
        float rotation = getRandomRotation();
        startPiece.transform.Rotate(new Vector3(0, rotation, 0));
        // Add it to our generated object list
        generatedObjects.Add(startPiece);
        return startPiece.GetComponent<SnappablePiece>();
    }

    /// <summary>
    /// Generate the level piece at the end of the level
    /// </summary>
    /// <returns></returns>
    private bool generateEndPoint()
    {
        // Get the last piece placed before now so we can connect the end piece to it
        SnappablePiece startPiece = populationQueue[0];
        // Keep track of whether placement was successful
        bool successfulPlacement = true;
        // Get the connectors on the previously placed piece
        List<Connector> connectors = startPiece.getConnectors();
        // Use foreach loop to find which connector is not connected
        foreach (Connector connector in connectors)
        {
            // We only want the unconnected connector
            if (connector.isConnected())
                continue;
            // Keep track of success for each individual end piece attempt
            bool success = false;
            SnappablePiece newPiece;
            // Get a list of all the end pieces we could place
            List<SnappablePiece> pieceList = new List<SnappablePiece>(settings.tileset.endPieces);
            do
            {
                // Get a random end piece. We don't have to aim for a target destination so we don't care which end piece we use
                SnappablePiece pieceToGenerate = getRandomPiece(pieceList);
                // Remove it from the list in case we fail and have to try again with another piece
                pieceList.Remove(pieceToGenerate);
                // Instantiate the chosen piece
                newPiece = Instantiate(pieceToGenerate, transform);
                // Get the instantiated piece's connectors
                List<Connector> newPieceConnectors = new(newPiece.getConnectors());
                // Try every connector on the end piece. These should really only have one but it doesn't hurt to have multiple
                while (newPieceConnectors.Count > 0)
                {
                    Connector newConnector;
                    // Get a connector from our end piece
                    newConnector = newPiece.getConnectors()[0];
                    // Remove it from the list in case we need to try again
                    newPieceConnectors.Remove(newConnector);
                    // Figure out how to rotate piece to make connectors face each other
                    Quaternion rotateAmount = getAmountToRotate(connector.getConnectorNormal(), newConnector.getConnectorNormal());
                    // Prevent piece from being placed upside down since mathematically it's a valid rotation to make the connectors face each other
                    if (rotateAmount.x != 0)
                    {
                        // For x rotation we also then have to spin the piece around on the y axis to prevent it facing backwards
                        Quaternion xFlipper = Quaternion.Euler(new(180, 180, 0));
                        rotateAmount *= xFlipper;
                    }
                    if (rotateAmount.z != 0)
                    {
                        rotateAmount.z = 0;
                    }
                    // Rotate the end piece
                    newPiece.gameObject.transform.rotation *= rotateAmount;
                    // Find amount to move by to make connectors touch
                    Vector3 moveAmount = connector.transform.position - newConnector.transform.position;
                    newPiece.gameObject.transform.position += moveAmount;
                    // Check that the piece hasn't collided with any previously placed pieces
                    bool collision = checkCollisionAgainstPreviousPieces(newPiece);
                    // Mark whether this attempt was successful
                    success = !collision;
                    if (collision)
                    {
                        // We're going to clear the failed attempt later, so just break
                        break;
                    }
                    // Successful placement, so mark as connected and add to generated object list
                    newConnector.setConnected(true);
                    connector.setConnected(true);
                    generatedObjects.Add(newPiece.gameObject);
                    break;
                }
                // If we failed, do some cleanup
                if (!success)
                {
                    DestroyImmediate(newPiece.gameObject);
                    newPiece = null;
                }
                // Keep going until we either succeed or run out of pieces to try
            } while (!success && pieceList.Count > 0);
            // If we succeeded
            if (newPiece)
            {
                successfulPlacement = true;
                break;
            }
            else
            {
                // We failed, so we're gonna have to restart generation
                //Debug.Log("Fatal collision");
                successfulPlacement = false;
                break;
            }
        }
        return successfulPlacement;
    }

    /// <summary>
    /// Populate the connectors of the level piece
    /// </summary>
    /// <param name="startPiece">Piece to populate</param>
    /// <param name="targetPosition">Target position. This is usually the target room position</param>
    /// <returns></returns>
    private bool populateConnections(SnappablePiece startPiece, Vector3 targetPosition)
    {
        // Keep track of whether placement was successful
        bool successfulPlacement = true;
        // Get the connectors from the previously placed piece
        List<Connector> connectors = startPiece.getConnectors();
        // Foreach loop to find the unconnected connector
        foreach (Connector connector in connectors)
        {
            // We only care about the unconnected connector
            if (connector.isConnected())
                continue;
            // Keep track of success for each individual level piece we attempt to place
            bool success = false;
            SnappablePiece newPiece;
            // Get the list of pieces that we can spawn
            List<SnappablePiece> pieceList = new List<SnappablePiece>(settings.tileset.standardPieces);
            do
            {
                // We get a piece pseudo-randomly from the list. It's weighted to give pieces that will get us closer to our target better odds of being chosen
                SnappablePiece pieceToGenerate = getRandomPieceWithLinearWeighting(getPieceListSortedByDistance(pieceList, connector, targetPosition));
                // Remove the piece from the list in case we have to try again
                pieceList.Remove(pieceToGenerate);
                // Get the ID of the best connector from the new piece to try and connect to our existing level in order to get as close to the target as possible
                int optimalConnector = pieceToGenerate.getOptimalConnectorLayoutForDistance(connector, targetPosition).Item1;
                // Instantiate the chosen piece
                newPiece = Instantiate(pieceToGenerate, transform);
                // Get the list of all connectors from the newly instantiated level piece
                List<Connector> newPieceConnectors = new(newPiece.getConnectors());
                while (newPieceConnectors.Count > 0)
                {
                    Connector newConnector;
                    // Get the optimal connector to connect to our existing level
                    newConnector = newPiece.getConnectors()[optimalConnector];
                    // Remove from the list in case we have to try again with a different connector
                    newPieceConnectors.Remove(newConnector);
                    // Figure out how to rotate piece to make connectors face each other
                    Quaternion rotateAmount = getAmountToRotate(connector.getConnectorNormal(), newConnector.getConnectorNormal());
                    // Prevent piece from being placed upside down since mathematically it's a valid rotation to make the connectors face each other
                    if (rotateAmount.x != 0)
                    {
                        // For x rotation we also then have to spin the piece around on the y axis to prevent it facing backwards
                        Quaternion xFlipper = Quaternion.Euler(new(180, 180, 0));
                        rotateAmount *= xFlipper;
                    }
                    if (rotateAmount.z != 0)
                    {
                        rotateAmount.z = 0;
                    }
                    // Rotate the level piece
                    newPiece.gameObject.transform.rotation *= rotateAmount;
                    // Find amount to move by to make connectors touch
                    Vector3 moveAmount = connector.transform.position - newConnector.transform.position;
                    newPiece.gameObject.transform.position += moveAmount;
                    // Check that the new piece hasn't collided with any previously placed level pieces
                    bool collision = checkCollisionAgainstPreviousPieces(newPiece);
                    success = !collision;
                    if (collision)
                    {
                        // if it has, break and we'll clean up later
                        break;
                    }
                    // Successful placement, so mark connectors as connected and add piece to generated objects list
                    newConnector.setConnected(true);
                    connector.setConnected(true);
                    generatedObjects.Add(newPiece.gameObject);
                    break;
                }
                // Do cleanup on the piece we failed to place
                if (!success)
                {
                    DestroyImmediate(newPiece.gameObject);
                    newPiece = null;
                }
                // Keep going until we succeed or run out of pieces to try
            } while (!success && pieceList.Count > 0);
            // If we succeeded, add the generated piece to the population queue
            if (newPiece)
            {
                successfulPlacement = true;
                populationQueue.Add(newPiece);
                break;
            }
            // We failed, so we have to try the level generation again
            else
            {
                //Debug.Log("Fatal collision");
                successfulPlacement = false;
                break;
            }
        }
        return successfulPlacement;
    }

    /// <summary>
    /// Calculate how much to rotate the level pieces to make the connectors face each other
    /// </summary>
    /// <param name="firstConnectorNormal"></param>
    /// <param name="secondConnectorNormal"></param>
    /// <returns></returns>
    private Quaternion getAmountToRotate(Vector3 firstConnectorNormal, Vector3 secondConnectorNormal)
    {
        // From second connector's normal to the inverse of the first so they face each other
        Quaternion rotationAmount = Quaternion.FromToRotation(secondConnectorNormal, -firstConnectorNormal);
        return rotationAmount;
    }

    /// <summary>
    /// Check the collision of the level piece against all previously placed level pieces except the one it was connected to
    /// </summary>
    /// <param name="newPiece">The piece to check collision against</param>
    /// <returns></returns>
    private bool checkCollisionAgainstPreviousPieces(SnappablePiece newPiece)
    {
        // Used to track if we get a collision
        bool collision = false;
        // Find the centre of the collision box of the new piece we're checking collision against. We do it now so we only do the maths once
        Vector3 newPieceCentre = newPiece.transform.rotation * newPiece.GetComponent<BoxCollider>().center + newPiece.transform.position;
        // Get the size of the collision box
        Vector3 newPieceBoxSize = newPiece.GetComponent<BoxCollider>().size;
        // Apply rotation to the collision box and create a new AABB around it
        newPieceBoxSize = rotateCollisionBox(newPieceCentre, newPieceBoxSize, newPiece.transform.rotation.eulerAngles);
        // For all pieces except the one we're connecting to
        // The piece we're connecting to will be last in the list
        for (int i = 0; i < generatedObjects.Count - 1; i++)
        {
            // Find the centre of the collision box of the existing piece we're currently checking against
            Vector3 oldPieceCentre = generatedObjects[i].transform.rotation * generatedObjects[i].GetComponent<BoxCollider>().center + generatedObjects[i].transform.position;
            // Get the size of the collision box
            Vector3 oldPieceSize = generatedObjects[i].GetComponent<BoxCollider>().size;
            // Apply rotation to the collision box and create a new AABB around it
            oldPieceSize = rotateCollisionBox(oldPieceCentre, oldPieceSize, generatedObjects[i].transform.rotation.eulerAngles);
            // Check collision. Half the size since we measure from the centre
            if (intersects(newPieceCentre, newPieceBoxSize * 0.5f, oldPieceCentre, oldPieceSize * 0.5f))
            {
                //Debug.Log("New piece centre: " + newPieceCentre.x + ", " + newPieceCentre.y + ", " + newPieceCentre.z);
                //Debug.Log("New piece size: " + newPieceBoxSize.x + ", " + newPieceBoxSize.y + ", " + newPieceBoxSize.z);
                //Debug.Log("Old piece centre: " + oldPieceCentre.x + ", " + oldPieceCentre.y + ", " + oldPieceCentre.z);
                //Debug.Log("Old piece size: " + oldPieceSize.x + ", " + oldPieceSize.y + ", " + oldPieceSize.z);
                //Debug.Log("Collision between " + newPiece.name + " and " + generatedObjects[i].name);
                collision = true;
                // If we ever get any collision, that's enough to know we have to try again, so break early
                break;
            }
        }

        return collision;
    }

    /// <summary>
    /// Creates a new AABB by rotating an existing one. Doesn't technically rotate the old box as much as rotates the old one then builds a new box around it that is axis aligned
    /// </summary>
    /// <param name="centre"></param>
    /// <param name="size"></param>
    /// <param name="rotation"></param>
    /// <returns></returns>
    private Vector3 rotateCollisionBox(Vector3 centre, Vector3 size, Vector3 rotation)
    {
        // Calculate corners of bounding box
        List<Vector3> corners = new List<Vector3>();
        for (int xMult = -1; xMult <= 1; xMult += 2)
        {
            for (int yMult = -1; yMult <= 1; yMult += 2)
            {
                for (int zMult = -1; zMult <= 1; zMult += 2)
                {
                    corners.Add(centre + new Vector3(size.x * xMult, size.y * yMult, size.z * zMult) * 0.5f);
                }
            }
        }
        // Rotate the corners of the box
        Quaternion rotator = Quaternion.Euler(rotation);
        List<Vector3> rotatedCorners = new List<Vector3>();
        foreach (Vector3 corner in corners)
        {
            // Get displacement from centre to the corner
            Vector3 displacement = corner - centre;
            // Rotate displacement
            displacement = rotator * displacement;
            // Add it back to the centre
            rotatedCorners.Add(displacement + centre);
        }
        // Find new min and max for each coord
        float xMin, xMax, yMin, yMax, zMin, zMax;
        xMin = rotatedCorners[0].x;
        xMax = rotatedCorners[0].x;
        yMin = rotatedCorners[0].y;
        yMax = rotatedCorners[0].y;
        zMin = rotatedCorners[0].z;
        zMax = rotatedCorners[0].z;
        for (int i = 1; i < rotatedCorners.Count; i++)
        {
            if (rotatedCorners[i].x < xMin)
                xMin = rotatedCorners[i].x;
            else if (rotatedCorners[i].x > xMax)
                xMax = rotatedCorners[i].x;
            if (rotatedCorners[i].y < yMin)
                yMin = rotatedCorners[i].y;
            else if (rotatedCorners[i].y > yMax)
                yMax = rotatedCorners[i].y;
            if (rotatedCorners[i].z < zMin)
                zMin = rotatedCorners[i].z;
            else if (rotatedCorners[i].z > zMax)
                zMax = rotatedCorners[i].z;
        }
        // We're returning the size of the collision box, the centre will stay the same
        return new Vector3(xMax - xMin, yMax - yMin, zMax - zMin);
    }

    /// <summary>
    /// Unity's default collision box intersection code requires a physics update for transforms to apply. This is used to get around that as doing that many phsyics updates would be very intensive
    /// </summary>
    /// <param name="pos1"></param>
    /// <param name="extents1"></param>
    /// <param name="pos2"></param>
    /// <param name="extents2"></param>
    /// <returns></returns>
    private bool intersects(Vector3 pos1, Vector3 extents1, Vector3 pos2, Vector3 extents2)
    {
        Vector3 min1 = pos1 - extents1;
        Vector3 max1 = pos1 + extents1;
        Vector3 min2 = pos2 - extents2;
        Vector3 max2 = pos2 + extents2;
        // Very standard AABB collision logic
        return min1.x < max2.x && max1.x > min2.x && min1.y < max2.y && max1.y > min2.y && min1.z < max2.z && max1.z > min2.z;
    }

    /// <summary>
    /// Get a random piece from within the provided piece list
    /// </summary>
    /// <param name="list"></param>
    /// <returns></returns>
    private SnappablePiece getRandomPiece(List<SnappablePiece> list)
    {
        SnappablePiece piece = null;
        // Generate a random index in the list
        int index = UnityEngine.Random.Range(0, list.Count);
        // Return that piece from the list
        piece = list[index];
        return piece;
    }

    /// <summary>
    /// Get a random piece from the list, except pieces earlier in the list are given a higher weighting that increases linearly
    /// </summary>
    /// <param name="list"></param>
    /// <returns></returns>
    private SnappablePiece getRandomPieceWithLinearWeighting(List<SnappablePiece> list)
    {
        // Make sure we have items in the list
        if (list.Count == 0)
            return null;
        SnappablePiece piece = null;
        // Create a list to hold the weightings of each piece in the list
        List<int> weightingList = new();
        // Keep track of the total weightings so far
        int weightingsTotal = 0;
        // Calculate weighting for each level piece
        for (int i = 0; i < list.Count; i++)
        {
            // Add a weighting equal to its position in the list, so pieces earlier in the list will have higher weighting. Currently this list will have higher weighting later in the list, but we invert the order later on
            weightingList.Add(i + weightingsTotal);
            weightingsTotal += i;
        }
        // Generate a random number between 0 and the highest weighting in the list. Unity random ints are non-inclusive so we add 1 to the total weightings
        int randomValue = UnityEngine.Random.Range(0, weightingsTotal + 1);
        // Figure out where in the weighting list we landed
        for (int i = 0; i < weightingList.Count; i++)
        {
            if (randomValue <= weightingList[i])
            {
                // We grab from the inverse position in the piece list since the list is ordered from most optimal to least but weightings are greater later in the list
                piece = list[list.Count - 1 - i];
                break;
            }
        }
        // If we somehow fail to generate a piece. This shouldn't happen but we'd rather suboptimal behaviour than a crash
        if (piece == null)
            piece = list[0];
        return piece;
    }

    /// <summary>
    /// Get a random rotation angle in a cardinal direction
    /// </summary>
    /// <returns></returns>
    private float getRandomRotation()
    {
        int rotID = UnityEngine.Random.Range(0, 4);
        switch (rotID)
        {
            case 0:
                return 0;
            case 1:
                return 90;
            case 2:
                return 180;
            case 3:
                return 270;
        }
        // Impossible to reach here but need a guaranteed return for compilation reasons
        return 0;
    }

    /// <summary>
    /// Get piece list sorted by distance with details about which connector is optimal and the distance from target position
    /// This function is no longer used but is kept for testing purposes
    /// </summary>
    /// <param name="pieces"></param>
    /// <param name="lastConnector"></param>
    /// <param name="targetLocation"></param>
    /// <returns></returns>
    private List<Tuple<SnappablePiece, int, float>> getPieceListSortedByDistanceWithDetails(List<SnappablePiece> pieces, Connector lastConnector, Vector3 targetLocation)
    {
        List<Tuple<SnappablePiece, int, float>> sortedList = new();
        foreach (SnappablePiece piece in pieces)
        {
            Tuple<int, int, float> optimalLayout = piece.getOptimalConnectorLayoutForDistance(lastConnector, targetLocation);
            bool foundPosition = false;
            for (int i = 0; i < sortedList.Count; i++)
            {
                if (optimalLayout.Item3 < sortedList[i].Item3)
                {
                    foundPosition = true;
                    sortedList.Insert(i, new(piece, optimalLayout.Item1, optimalLayout.Item3));
                    break;
                }
            }
            if (!foundPosition)
                sortedList.Add(new(piece, optimalLayout.Item1, optimalLayout.Item3));
        }
        return sortedList;
    }

    /// <summary>
    /// Sorts a piece list by distance to target location when the pieces are arranged optimally
    /// </summary>
    /// <param name="pieces"></param>
    /// <param name="lastConnector"></param>
    /// <param name="targetLocation"></param>
    /// <returns></returns>
    private List<SnappablePiece> getPieceListSortedByDistance(List<SnappablePiece> pieces, Connector lastConnector, Vector3 targetLocation)
    {
        // List for holding pieces with optimal layout and distance to target
        List<Tuple<SnappablePiece, int, float>> sortedList = new();
        // Go through each piece in the list
        foreach (SnappablePiece piece in pieces)
        {
            // Get optimal layout in terms of which connector to connect to the previous piece. Also contains distance to allow for sorting
            Tuple<int, int, float> optimalLayout = piece.getOptimalConnectorLayoutForDistance(lastConnector, targetLocation);
            bool foundPosition = false;
            // Find where in our sorted list to put it
            for (int i = 0; i < sortedList.Count; i++)
            {
                // If this piece we are adding would put us closer to the target
                if (optimalLayout.Item3 < sortedList[i].Item3)
                {
                    // Insert in the proper place in the list, then break
                    foundPosition = true;
                    sortedList.Insert(i, new(piece, optimalLayout.Item1, optimalLayout.Item3));
                    break;
                }
            }
            // If it's further than every other piece, add to end of list
            if (!foundPosition)
                sortedList.Add(new(piece, optimalLayout.Item1, optimalLayout.Item3));
        }
        // List for solely storing the pieces with no extra info
        List<SnappablePiece> pieceOnlyList = new();
        // Copy it over from our sorted list
        foreach (var item in sortedList)
        {
            pieceOnlyList.Add(item.Item1);
        }
        return pieceOnlyList;
    }

    /// <summary>
    /// Generate a room and connect it to the existing level
    /// </summary>
    /// <returns></returns>
    private bool generateRoom()
    {
        // Get the connectors of the previous piece
        var connectors = populationQueue[0].getConnectors();
        // Track whether we're successful in connecting the room to the previous level pieces
        bool success = true;
        // Foreach loop to find the unconnected connector
        foreach (var connector in connectors)
        {
            // We only care about the unconnected connector
            if (connector.isConnected())
                continue;
            // Instantiate the room and add it to our generated objects list
            GameObject room = Instantiate(roomPrefab.gameObject, transform);
            generatedObjects.Add(room);
            // Call the room's generation function to generate it with wave function collapse
            room.GetComponent<WaveFunctionCollapse>().generateRoom();
            // Grab the snappable piece component of the room
            SnappablePiece newPiece = room.GetComponent<SnappablePiece>();
            // Get the room's connectors, that were generated as part of the room generation code
            var newPieceConnectors = newPiece.getConnectors();
            // For each connector in the room
            while (newPieceConnectors.Count > 0)
            {
                Connector newConnector;
                // Grab the first connector in the room
                newConnector = newPiece.getConnectors()[0];
                // Remove it from the list just in case we need to try again
                newPieceConnectors.Remove(newConnector);
                // Figure out how to rotate room to make connectors face each other
                Quaternion rotateAmount = getAmountToRotate(connector.getConnectorNormal(), newConnector.getConnectorNormal());
                // Prevent the room from being flipped upside down. Don't need to consider z since room connectors only generate top and bottom and not left and right of room
                if (rotateAmount.x != 0)
                {
                    // Need to rotate 180 degrees on y axis as well if we flip over x axis so room isn't backwards
                    Quaternion xFlipper = Quaternion.Euler(new(180, 180, 0));
                    rotateAmount *= xFlipper;

                }
                // Rotate the room
                newPiece.gameObject.transform.rotation *= rotateAmount;
                // Find amount to move by to make connectors touch
                Vector3 moveAmount = connector.transform.position - newConnector.transform.position;
                newPiece.gameObject.transform.position += moveAmount;
                // Check that the room hasn't collided with any of the previous level pieces
                // Unlike piece generation, we get one shot at this, so if the room fails to generate, cleanup will be done for the whole level, so don't need to do it here
                bool collision = checkCollisionAgainstPreviousPieces(newPiece);
                success = !collision;
                newConnector.setConnected(true);
                connector.setConnected(true);
                break;
            }
            // Clear the population queue and then add the room to it so the level keeps building from here
            populationQueue.Clear();
            populationQueue.Add(newPiece);
        }
        return success;
    }

    /// <summary>
    /// Delete all generated objects and clear all lists
    /// </summary>
    public void deleteLevel()
    {
        // Destroy all generated level elements
        while (generatedObjects.Count > 0)
        {
            if (generatedObjects[0])
            {
                // Destroy immediate so it works in editor
                DestroyImmediate(generatedObjects[0]);
            }
            generatedObjects.RemoveAt(0);
        }
        // Clear the population queue
        while (populationQueue.Count > 0)
        {
            if (populationQueue[0])
            {
                // Destroy immediate so it works in editor
                DestroyImmediate(populationQueue[0]);
            }
            populationQueue.RemoveAt(0);
        }
        // Clear the room position list
        roomPositions = new();
    }

    /// <summary>
    /// Generate the positions where we want to generate rooms
    /// </summary>
    private void generateRoomPositions()
    {
        // Start at 0, 0, 0 as that's where the level start is
        Vector3 position = new(0, 0, 0);
        // We generate 1 more room position than we need as we will use it for the position of the end piece
        for (int i = 0; i < settings.roomCount + 1; i++)
        {
            // Add a random amount between the ranges defined in the generator settings
            position.x += UnityEngine.Random.Range(settings.minRoomDistanceX, settings.maxRoomDistanceX);
            position.y += UnityEngine.Random.Range(settings.minRoomDistanceY, settings.maxRoomDistanceY);
            position.z += UnityEngine.Random.Range(settings.minRoomDistanceZ, settings.maxRoomDistanceZ);
            // Add it to our list
            roomPositions.Add(new Vector3(position.x, position.y, position.z));
        }
    }

    /// <summary>
    /// Calculate how far the unpopulated connector in the last generated level piece is from our current target room position
    /// </summary>
    /// <param name="currentRoom"></param>
    /// <returns></returns>
    private float calculateDistanceToNextRoom(int currentRoom)
    {
        // Get all connectors in the last generated piece
        List<Connector> connectors = populationQueue[0].getConnectors();
        Connector openConnector = connectors[0];
        // Check each connector to see if it's unconnected
        for (int i = 0; i < connectors.Count; i++)
        {
            if (!connectors[i].isConnected())
            {
                openConnector = connectors[i];
            }
        }
        // Calculate distance from unconnected connector to the room position we want to get to
        float distance = (roomPositions[currentRoom] - openConnector.transform.position).magnitude;
        return distance;
    }
}

#if UNITY_EDITOR
/// <summary>
/// Custom editor buttons to generate and delete levels
/// </summary>
[CustomEditor(typeof(LevelGenerator))]
public class LevelGeneratorEditor : Editor
{
    public override void OnInspectorGUI()
    {
        base.OnInspectorGUI();
        var levelGenerator = (LevelGenerator)target;
        if (GUILayout.Button("Generate Level"))
        {
            levelGenerator.generateLevel();
        }
        if (GUILayout.Button("Delete Level"))
        {
            levelGenerator.deleteLevel();
        }
    }
}
#endif